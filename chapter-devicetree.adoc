== The Device Tree

=== Overview
The ePAPR specifies a construct called a _device tree_ to describe
system hardware. A boot program loads a device tree into a client
program’s memory and passes a pointer to the device tree to the client.

This chapter describes the logical structure of the device tree and
specifies a base set of properties for use in describing device nodes.
Chapter 3 specifies certain device nodes required by an ePAPR- compliant
device tree. Chapter 6 describes the ePAPR defined device bindings— the
requirements for representing certain device types classes of devices.
Chapter 8 describes the in-memory encoding of the device tree.

A device tree is a tree data structure with nodes that describe the
devices in a system. Each node has property/value pairs that describe
the characteristics of the device being represented. Each node has
exactly one parent except for the root node, which has no parent.

An ePAPR-compliant device tree describes device information in a system
that cannot necessarily be dynamically detected by a client program. For
example, the architecture of PCI enables a client to probe and detect
attached devices, and thus device tree nodes describing PCI devices
might not be required. However, a device node is required to describe a
PCI host bridge device in the system if it cannot be detected by
probing.

==== Device Tree Example
Figure 2-1 shows an example representation of a simple device tree that
is nearly complete enough to boot a simple operating system, with the
platform type, CPU, and memory described. Device nodes are shown with
properties and values shown beside the node.

[FIXME] ADD EXAMPLE DIAGRAM

=== Device Tree Struture and Conventions
==== Node Names
===== Node Name Requirements
Each node in the device tree is named according to the following
convention:

[listing]
node-name@unit-address

The _node-name_ component specifies the name of the node. It shall be 1 to
31 characters in length and consist solely of characters from the set of
characters in Table 2-1[FIXME].

.Characters for node names
[width="30%"]
|===
|Character |Description
|0-9 |digit
|a-z |lowercase letter
|A-Z |uppercase letter
|, |comma
|. |period
|_ |underscore
|+ |plus sign
|- |dash
|===

The node-name shall start with a lower or uppercase character and should
describe the general class of
device.
The unit-address component of the name is specific to the bus type on
which the node sits. It consists
of one or more ASCII characters from the set of characters in Table 2-1.
The unit-address must
match the first address specified in the reg property of the node. If
the node has no reg property, the
@ and unit-address must be omitted and the node-name alone
differentiates the node from other nodes
at the same level in the tree. The binding for a particular bus may
specify additional, more specific
requirements for the format of reg and the unit-address.
The root node does not have a node-name or unit-address. It is
identified by a forward slash (/).

[discrete]
=== Example

See the node names examples in Figure 2-2

[FIXME] add example diagram

In the example:
• The nodes with the name cpu are distinguished by their unit-address
values of 0 and 1.
• The nodes with the name ethernet are distinguished by their
unit-address values of
FE001000 and FE002000.

==== Generic Names Recommendation
The name of a node should be somewhat generic, reflecting the function
of the device and not its
precise programming model. If appropriate, the name should be one of the
following choices:

* atm
* cache-controller
* compact-flash
* can
* cpu
* crypto
* disk
* display
* dma-controller
* ethernet
* ethernet-phy
* fdc
* flash
* gpio
* i2c
* ide
* interrupt-controller
* isa
* keyboard
* mdio
* memory
* memory-controller
* mouse
* nvram
* parallel
* pc-card
* pci
* pcie
* rtc
* sata
* scsi
* serial
* sound
* spi
* timer
* usb
* vme
* watchdog

==== Path Names

A node in the device tree can be uniquely identified by specifying the
full path from the root node,
through all descendant nodes, to the desired node.
The convention for specifying a device path is:
/node-name-1/node-name-2/node-name-N
For example, in Figure 2-2 the device path to cpu #1 would be:
/cpus/cpu@1
The path to the root node is /.
A unit address may be omitted if the full path to the node is
unambiguous.
If a client program encounters an ambiguous path, its behavior is
undefined.

==== Properties

Each node in the device tree has properties that describe the
characteristics of the node. Properties
consist of a name and a value.

===== Property Names
Property names are strings of 1 to 31 characters from the following set
of characters.

.Characters for property names
[width="30%"]
|===
|Character |Description
|0-9 |digit
|a-z |lowercase letter
|, |comma
|. |period
|_ |underscore
|+ |plus sign
|- |dash
|? |question mark
|# |hash
|===

Nonstandard property names should specify a unique string prefix, such
as a stock ticker symbol,
identifying the name of the company or organization that defined the
property. Examples:

[listing]
fsl,channel-fifo-len
ibm,ppc-interrupt-server#s
linux,network-index

===== Property Values
A property value is an array of zero or more bytes that contain
information associated with the
property.

Properties might have an empty value if conveying true-false
information. In this case, the presence or
absence of the property is sufficiently descriptive.

Table 2-3 describes the set of basic value types defined by the ePAPR.

.Property Values
|===
|Value |Description
|<empty> |
Value is empty—used for conveying true-false information, when the
presence of absence of the property itself is sufficiently descriptive.
|<u32> |
A 32-bit integer in big-endian format. Example: the 32-bit value
0x11223344 would be represented in memory as:
address
address+1
address+2
address+3
11
22
33
44
|<u64> |
Represents a 64-bit integer in big-endian format. Consists of two <u32>
values where the first value contains the most significant bits of the
integer
and the second value contains the least significant bits.
Example: the 64-bit value 0x1122334455667788 would be represented as
two cells as: <0x11223344 0x55667788>.
The value would be represented in memory as:
address
address+1
address+2
address+3
address+4
address+5
address+6
address+7
11
22
33
44
55
66
77
88
|<string> |
Strings are printable and null-terminated. Example: the string “hello”
would
be represented in memory as:
address
address+1
address+2
address+3
address+4
address+5
68
65
6C
6C
6F
00
|<prop-encoded-array> |
Format is specific to the property. See the property definition.
|<phandle> |A <u32> value. A phandle value is a way to reference another
node in the
device tree. Any node that can be referenced defines a phandle property
with a unique <u32> value. That unique number is specified for the value
of
properties with a phandle value type.
|<stringlist> |A list of <string> values concatenated together. Example:
The string list
“hello”,“world” would be represented in memory as:
address
address+1
address+2
address+3
address+4
address+5
address+6
address+7
address+8
address+9
address+10
address+11
68
65
6C
6C
6F
00
77
6F
72
6C
64
00
|===

=== Standard Properties
The ePAPR specifies a set of standard properties for device nodes. These
properties are described in
detail in this section. Device nodes defined by the ePAPR (see Chapter
3, Device Node
Requirements) may specify additional requirements or constraints
regarding the use of the standard
properties. Device bindings (Chapter 6) that describe the representation
of specific devices may also
specify additional requirements.

Note: All examples of device tree nodes in this document use the Device
Tree Source (DTS) format
for specifying nodes and properties.

==== compatible
Property: compatible
Value type: <stringlist>
Description:
The compatible property value consists of one or more strings that
define the specific
programming model for the device. This list of strings should be used by
a client program for
device driver selection. The property value consists of a concatenated
list of null terminated
strings, from most specific to most general. They allow a device to
express its compatibility
with a family of similar devices, potentially allowing a single device
driver to match against
several devices.

The recommended format is “manufacturer,model”, where manufacturer is a
string describing the name of the manufacturer (such as a stock ticker
symbol), and model
specifies the model number.
Example:
compatible = “fsl,mpc8641-uart”, “ns16550";
In this example, an operating system would first try to locate a device
driver that supported
fsl,mpc8641-uart. If a driver was not found, it would then try to locate
a driver that supported
the more general ns16550 device type.

==== model
