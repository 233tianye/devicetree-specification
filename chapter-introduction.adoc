== Introduction
=== Purpose and Scope
To initialize and boot a computer system, various software components
interact—firmware might
perform low-level initialization of the system hardware before passing
control to software such as an operating system, bootloader, or
hypervisor. Bootloaders and hypervisors can, in turn, load and transfer
control to operating systems. Standard, consistent interfaces and
conventions facilitate the interactions between these software
components. In this document the term _boot program_ is used to
generically refer to a software component that initializes the system
state and executes another software component referred to as a _client
program_. Examples of a boot programs include: firmware, bootloaders, and
hypervisors. Examples of a client program include: bootloaders,
hypervisors, operating systems, and special purpose programs. A piece of
software (e.g. a hypervisor) may be both a client program and a boot
program.

This specification, the Embedded Power Architecture Platform
Requirements (ePAPR), provides a complete boot program to client program
interface definition, combined with minimum system requirements that
facilitate the development of a wide variety of embedded systems based
on CPUs that implement the Power architecture as defined in the Power
ISA^TM^ [1].

This specification is targeted towards the requirements of embedded
systems. An embedded system typically consists of system hardware, an
operating system, and application software that are custom designed to
perform a fixed, specific set of tasks. This is unlike general purpose
computers, which are designed to be customized by a user with a variety
of software and I/O devices. Other characteristics of embedded systems
can include:
* a fixed set of I/O devices, possibly highly customized for the application
* a system board optimized for size and cost
* limited user interface
* resource constraints like limited memory and limited nonvolatile storage
* real-time constraints
* use of a wide variety of operating systems, including Linux, real-time operating systems, and
custom or proprietary operating systems

=== Organization of this Document

Chapter 1 introduces the architecture being specified by the ePAPR.
Chapter 2 introduces the device tree concept and describes its logical structure and standard
properties.
Chapter 3 specifies the definition of a base set of device nodes required by ePAPR-compliant
device trees.
Chapter 4 specifies the ELF client program image format.
Chapter 5 specifies the requirements for boot programs to start client programs on single and
multiple CPU systems.
Chapter 6 describes device bindings for certain classes of devices and specific device types.
Chapter 7 describes ePAPR virtualization extensions-- hypercall ABI, hypercall APIs, and
device tree conventions related to virtualization.
Chapter 8 specifies the physical structure of device trees.

=== Conventions Used in this Document
The word _shall_ is used to indicate mandatory requirements strictly to
be followed in order to conform to the standard and from which no
deviation is permitted (_shall_ equals _is required to_).

The word _should_ is used to indicate that among several possibilities
one is recommended as particularly suitable, without mentioning or
excluding others; or that a certain course of action is preferred but
not necessarily required; or that (in the negative form) a certain
course of action is deprecated but not prohibited (_should_ equals _is
recommended that_).

The word _may_ is used to indicate a course of action permissible within
the limits of the standard (_may_ equals _is permitted_).

Examples of device tree constructs are frequently shown in _Device Tree
Syntax_ form. See _Appendix A Device Tree Source Format (version 1)_ for
an overview of this syntax.

=== Relationship to IEEE^TM^ 1275
The ePAPR is loosely related to the IEEE 1275 Open Firmware
standard—_IEEE Standard for Boot (Initialization Configuration)
Firmware: Core Requirements and Practices_ <<1>>.

The original IEEE 1275 specification and its derivatives such as CHRP
<<10>> and PAPR <<16>> address problems of general purpose
computers, such as how a single version of an operating system can work
on several different computers within the same family and the problem of
loading an operating system from user-installed I/O devices.

Because of the nature of embedded systems, some of these problems faced
by open, general purpose computers do not apply. Notable features of the
IEEE 1275 specification that are omitted from the ePAPR include:
* Plug-in device drivers
* FCode
* The programmable Open Firmware user interface based on Forth
* FCode debugging
* Operating system debugging

What _is_ retained from IEEE-1275 are concepts from the device tree
architecture by which a boot program can describe and communicate system
hardware information to client program, thus eliminating the need for
the client program to have hard-coded descriptions of system hardware.

=== 32-bit and 64-bit Support
The ePAPR supports CPUs with both 32-bit and 64-bit addressing
capabilities. Where applicable, sections of the ePAPR describe any
requirements or considerations for 32-bit and 64-bit addressing.

=== References
[bibliography]
- [[[1]]] _Power ISA^TM^_, Version 2.06 Revision B, July 23, 2010. It is available from power.org
(http://power.org)

- [[[2]]] _Boot (Initialization Configuration) Firmware: Core
  Requirements and Practices_, 1994, This is the core standard (also
  known as IEEE 1275) that defines the device tree concept adopted by
  the ePAPR. It is available from Global Engineering (http://global.ihs.com/).

- [[[3]]] _PowerPC Processor Binding to IEEE 1275-1994 Standard for Boot
  (Initialization, Configuration) Firmware_, Version 2.1, Open Firmware
  Working Group, (http://playground.sun.com/1275/bindings/ppc/release/ppc-2_1.html),
  1996, This document specifies the PowerPC processor specific binding
  to the base standard.

- [[[4]]] _booting-without-of.txt_, Ben Herrenschmidt, Becky Bruce, et al., From the Linux kernel source tree
(http://www.kernel.org/), Describes the device tree as used by the Linux kernel.

- [[[5]]] _Device Trees Everywhere_, David Gibson and Ben Herrenschmidt
(http://ozlabs.org/~dgibson/home/papers/dtc-paper.pdf),
An overview of the concept of the device tree and device tree compiler.

- [[[6]]] _PCI Bus Binding to: IEEE Std 1275-1994 Standard for Boot (Initialization Configuration)
Firmware_, Revision 2.1, Open Firmware Working Group, 1998
(http://playground.sun.com/1275/bindings/pci/pci2_1.pdf)

- [[[7]]] _Open Firmware Recommended Practice: Interrupt Mapping_, Version 0.9,
Open Firmware Working Group, 1996 (http://playground.sun.com/1275/practice/imap/imap0_9d.pdf)

- [[[8]]] _Open Firmware Recommended Practice: Device Support Extensions_, Version 1.0,
Open Firmware Working Group, 1997,
(http://playground.sun.com/1275/practice/devicex/dse1_0a.html) This document describes the binding
for various device types such as network, RTC, keyboard, sound, etc.

- [[[9]]] _Open Firmware Recommended Practice: Universal Serial Bus
  Binding to IEEE 1275_, Version 1, Open Firmware
  Working Group, 1998 (http://playground.sun.com/1275/bindings/usb/usb-1_0.ps)

- [[[10]]] _PowerPC Microprocessor Common Hardware Reference Platform (CHRP) Binding_, Version 1.8,
  Published by the Open Firmware Working Group, 1998 (http://playground.sun.com/1275/bindings/chrp/chrp1_8a.ps). This document specifies the properties for Open PIC-compatible interrupt controllers.

- [[[11]]] _CHRP ISA Interrupt Controller Device Binding_, Unapproved Draft version 1.1,
Published by the Open Firmware Working Group, Aug 19, 1996
(http://playground.sun.com/1275/bindings/devices/postscript/isa-pic-1_1d.ps)

- [[[12]]] _The Open Programmable Interrupt Controller (PIC) Register
  Interface Specification_, Revision 1.2,
  Advanced Micro Devices and Cyrix Corporation, October 1995

- [[[13]]] _PCI Local Bus Specification_, Revision 2.2, PCI Special Interest Group
- [[[14]]] _PCI Express Base Specification_, Revision 1.0a, PCI Special Interest Group
- [[[15]]] _PCI-Express Binding to OF_, P1275 Openboot Working Group Proposal, 18 August 2004
- [[[16]]] _Power.org Standard for Power Architecture Platform Requirements_, power.org

- [[[17]]]
_System V Application Binary Interface, Edition 4.1_,
Published by The Santa Cruz Operation, Inc., 1997

- [[[18]]]
_The Open Programmable Interrupt Controller (PIC) Register
Interface Specification Revision 1.2_,
AMD and Cyrix, October 1995

- [[[19]]]
_RFC 2119, Key words for use in RFCs to Indicate Requirement Levels_,
http://www.ietf.org/rfc/rfc2119.txt

- [[[20]]]
_64-bit PowerPC ELF Application Binary Interface Supplement 1.9_,
Ian Lance Taylor, 2004

== Definition of Terms
[glossary]
AMP:: Asymmetric Multiprocessing. Computer architecture where two or more CPUs are
executing different tasks. Typically, an AMP system executes different operating system
images on separate CPUs.
boot CPU. The first CPU which a boot program directs to a client program’s entry point.

Book III-E:: Embedded Environment. Section of the Power ISA defining supervisor
instructions and related facilities used in embedded Power processor implementations.
boot program. Used to generically refer to a software component that initializes the system
state and executes another software component referred to as a client program. Examples of a
boot programs include: firmware, bootloaders, and hypervisors. Examples of a client
program include: bootloaders, hypervisors, operating systems, and special purpose programs.
client program. Program that typically contains application or operating system software.
cell. A unit of information consisting of 32 bits.

DMA:: Direct memory access
DTB:: Device tree blob. Compact binary representation of the device tree.
DTC:: Device tree compiler. An open source tool used to create DTB files from DTS files.
DTS:: Device tree syntax. A textual representation of a device tree consumed by the DTC.
See Appendix A Device Tree Source Format (version 1).

effective address::
Memory address as computed by processor storage access or branch
instruction.

physical address::
Address used by the processor to access external device, typically a
memory controller. The Power ISA uses the real address when referring to a physical address.
Power ISA. Power Instruction Set Architecture.

interrupt specifier::
A property value that describes an interrupt. Typically information that
specifies an interrupt number and sensitivity and triggering mechanism is included.
secondary CPU. CPUs other than the boot CPU that belong to the client program are
considered secondary CPUs.

SMP::
Symmetric multiprocessing. A computer architecture where two or more identical
CPUs can execute the same task. Typically an SMP system executes a single operating
system image.

SOC::
System on a chip. A single computer chip integrating one or more CPU core as well as
number of other peripherals.

unit address::
The part of a node name specifying the node’s address in the address space of
the parent node.

quiescent CPU::
A quiescent CPU is in a state where it cannot interfere with the normal
operation of other CPUs, nor can its state be affected by the normal operation of other
running CPUs, except by an explicit method for enabling or re-enabling the quiescent CPU.

